// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title FlashloanArbitrage
 * @notice Template contract for executing flashloan arbitrage strategies
 * @dev This is a reference implementation. Generated by VibeAgent.
 */

interface IFlashLoanReceiver {
    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    ) external returns (bool);
}

interface IPool {
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata modes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

interface ISwapRouter {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    function exactInputSingle(ExactInputSingleParams calldata params)
        external
        payable
        returns (uint256 amountOut);
}

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract FlashloanArbitrage is IFlashLoanReceiver {
    address public immutable owner;
    IPool public immutable pool;
    
    struct ArbitrageParams {
        address router1;
        address router2;
        address tokenIn;
        address tokenOut;
        uint24 fee1;
        uint24 fee2;
        uint256 minProfit;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
    
    constructor(address _pool) {
        owner = msg.sender;
        pool = IPool(_pool);
    }
    
    /**
     * @notice Execute flashloan arbitrage
     * @param asset Token to flashloan
     * @param amount Amount to borrow
     * @param params Encoded ArbitrageParams
     */
    function executeArbitrage(
        address asset,
        uint256 amount,
        bytes memory params
    ) external onlyOwner {
        address[] memory assets = new address[](1);
        assets[0] = asset;
        
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = amount;
        
        uint256[] memory modes = new uint256[](1);
        modes[0] = 0; // No debt, pay back immediately
        
        pool.flashLoan(
            address(this),
            assets,
            amounts,
            modes,
            address(this),
            params,
            0
        );
    }
    
    /**
     * @notice Callback function called by Aave pool
     * @dev Executes the arbitrage strategy
     */
    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    ) external override returns (bool) {
        require(msg.sender == address(pool), "Not pool");
        require(initiator == address(this), "Not initiator");
        
        ArbitrageParams memory arbParams = abi.decode(params, (ArbitrageParams));
        
        // Step 1: Swap on first DEX
        IERC20(arbParams.tokenIn).approve(arbParams.router1, amounts[0]);
        
        ISwapRouter.ExactInputSingleParams memory swapParams1 = ISwapRouter
            .ExactInputSingleParams({
                tokenIn: arbParams.tokenIn,
                tokenOut: arbParams.tokenOut,
                fee: arbParams.fee1,
                recipient: address(this),
                deadline: block.timestamp,
                amountIn: amounts[0],
                amountOutMinimum: 0,
                sqrtPriceLimitX96: 0
            });
        
        uint256 amountOut1 = ISwapRouter(arbParams.router1).exactInputSingle(
            swapParams1
        );
        
        // Step 2: Swap back on second DEX
        IERC20(arbParams.tokenOut).approve(arbParams.router2, amountOut1);
        
        ISwapRouter.ExactInputSingleParams memory swapParams2 = ISwapRouter
            .ExactInputSingleParams({
                tokenIn: arbParams.tokenOut,
                tokenOut: arbParams.tokenIn,
                fee: arbParams.fee2,
                recipient: address(this),
                deadline: block.timestamp,
                amountIn: amountOut1,
                amountOutMinimum: amounts[0] + premiums[0] + arbParams.minProfit,
                sqrtPriceLimitX96: 0
            });
        
        uint256 amountOut2 = ISwapRouter(arbParams.router2).exactInputSingle(
            swapParams2
        );
        
        // Step 3: Repay flashloan
        uint256 amountOwed = amounts[0] + premiums[0];
        require(
            amountOut2 >= amountOwed + arbParams.minProfit,
            "Not profitable"
        );
        
        IERC20(assets[0]).approve(address(pool), amountOwed);
        
        // Transfer profit to owner
        uint256 profit = amountOut2 - amountOwed;
        IERC20(assets[0]).transfer(owner, profit);
        
        return true;
    }
    
    /**
     * @notice Emergency withdrawal
     */
    function emergencyWithdraw(address token) external onlyOwner {
        uint256 balance = IERC20(token).balanceOf(address(this));
        IERC20(token).transfer(owner, balance);
    }
    
    receive() external payable {}
}
