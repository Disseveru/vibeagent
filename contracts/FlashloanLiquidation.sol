// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title FlashloanLiquidation
 * @notice Template contract for executing flashloan liquidation strategies
 * @dev This is a reference implementation. Generated by VibeAgent.
 */

interface IFlashLoanReceiver {
    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    ) external returns (bool);
}

interface IPool {
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata modes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;
    
    function liquidationCall(
        address collateralAsset,
        address debtAsset,
        address user,
        uint256 debtToCover,
        bool receiveAToken
    ) external;
}

interface ISwapRouter {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    function exactInputSingle(ExactInputSingleParams calldata params)
        external
        payable
        returns (uint256 amountOut);
}

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract FlashloanLiquidation is IFlashLoanReceiver {
    address public immutable owner;
    IPool public immutable pool;
    
    struct LiquidationParams {
        address userToLiquidate;
        address collateralAsset;
        address debtAsset;
        uint256 debtToCover;
        address swapRouter;
        uint24 swapFee;
        uint256 minProfit;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
    
    constructor(address _pool) {
        owner = msg.sender;
        pool = IPool(_pool);
    }
    
    /**
     * @notice Execute flashloan liquidation
     * @param debtAsset Token to flashloan (the debt token)
     * @param debtAmount Amount to borrow
     * @param params Encoded LiquidationParams
     */
    function executeLiquidation(
        address debtAsset,
        uint256 debtAmount,
        bytes memory params
    ) external onlyOwner {
        address[] memory assets = new address[](1);
        assets[0] = debtAsset;
        
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = debtAmount;
        
        uint256[] memory modes = new uint256[](1);
        modes[0] = 0; // No debt, pay back immediately
        
        pool.flashLoan(
            address(this),
            assets,
            amounts,
            modes,
            address(this),
            params,
            0
        );
    }
    
    /**
     * @notice Callback function called by Aave pool
     * @dev Executes the liquidation strategy
     */
    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    ) external override returns (bool) {
        require(msg.sender == address(pool), "Not pool");
        require(initiator == address(this), "Not initiator");
        
        LiquidationParams memory liqParams = abi.decode(
            params,
            (LiquidationParams)
        );
        
        // Step 1: Approve pool to take debt tokens for liquidation
        IERC20(liqParams.debtAsset).approve(
            address(pool),
            liqParams.debtToCover
        );
        
        // Step 2: Execute liquidation
        pool.liquidationCall(
            liqParams.collateralAsset,
            liqParams.debtAsset,
            liqParams.userToLiquidate,
            liqParams.debtToCover,
            false // Receive actual tokens, not aTokens
        );
        
        // Step 3: Swap collateral to debt token
        uint256 collateralReceived = IERC20(liqParams.collateralAsset)
            .balanceOf(address(this));
        
        IERC20(liqParams.collateralAsset).approve(
            liqParams.swapRouter,
            collateralReceived
        );
        
        ISwapRouter.ExactInputSingleParams memory swapParams = ISwapRouter
            .ExactInputSingleParams({
                tokenIn: liqParams.collateralAsset,
                tokenOut: liqParams.debtAsset,
                fee: liqParams.swapFee,
                recipient: address(this),
                deadline: block.timestamp,
                amountIn: collateralReceived,
                amountOutMinimum: amounts[0] + premiums[0] + liqParams.minProfit,
                sqrtPriceLimitX96: 0
            });
        
        uint256 amountOut = ISwapRouter(liqParams.swapRouter).exactInputSingle(
            swapParams
        );
        
        // Step 4: Repay flashloan
        uint256 amountOwed = amounts[0] + premiums[0];
        require(
            amountOut >= amountOwed + liqParams.minProfit,
            "Not profitable"
        );
        
        IERC20(assets[0]).approve(address(pool), amountOwed);
        
        // Transfer profit to owner
        uint256 profit = amountOut - amountOwed;
        IERC20(assets[0]).transfer(owner, profit);
        
        return true;
    }
    
    /**
     * @notice Emergency withdrawal
     */
    function emergencyWithdraw(address token) external onlyOwner {
        uint256 balance = IERC20(token).balanceOf(address(this));
        IERC20(token).transfer(owner, balance);
    }
    
    receive() external payable {}
}
